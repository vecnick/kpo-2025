package hse.kpo.services;

import static java.lang.Integer.parseInt;

import java.time.LocalDate;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import hse.kpo.grpc.ReportResponse;
import hse.kpo.grpc.ReportServiceGrpc;
import hse.kpo.tg.NotificationBot;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;

@Slf4j
@Service
@RequiredArgsConstructor
public class NotificationService {

    private final ReportServiceGrpc.ReportServiceBlockingStub reportService;
    private final NotificationBot notificationBot;

    @Scheduled(fixedRate = 60_000)  // –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
    public void checkSalesAndNotify() {
        log.warn("getting report");
        ReportResponse report = reportService.getLatestReport(null);
        parseAndSendNotifications(report.getContent());
    }

    private void parseAndSendNotifications(String reportContent) {
        // –û—Ç–¥–µ–ª—è–µ–º —Å–µ–∫—Ü–∏—é —Å –ø–æ–∫—É–ø–∞—Ç–µ–ª—è–º–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–π
        String[] parts = reportContent.split("–û–ø–µ—Ä–∞—Ü–∏—è: ");
        String customersSection = parts[0];

        // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ—Ö –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π
        List<CustomerData> customers = new ArrayList<>();
        Pattern customerPattern = Pattern.compile("Customer\\{([^}]+)\\}");
        Matcher matcher = customerPattern.matcher(customersSection);

        while (matcher.find()) {
            String customerData = matcher.group(1);
            customers.add(parseCustomer(customerData));
        }

        // –ü–∞—Ä—Å–∏–º –æ–ø–µ—Ä–∞—Ü–∏–∏ –ø—Ä–æ–¥–∞–∂
        int totalSales = parts.length - 1; // –ü–µ—Ä–≤–∞—è —á–∞—Å—Ç—å - –Ω–µ –æ–ø–µ—Ä–∞—Ü–∏—è

        // –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        Map<String, CustomerData> customerMap = new LinkedHashMap<>();
        int validCount = 0, invalidCount = 0;

        for (CustomerData customer : customers) {
            if (customer.isValid()) {
                customerMap.merge(customer.name(), customer, (old, neu) -> neu);
                validCount++;
            } else {
                invalidCount++;
            }
        }

        // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        StringBuilder message = new StringBuilder()
                .append("üè™ *–û—Ç—á–µ—Ç –æ –ø—Ä–æ–¥–∞–∂–∞—Ö*\n")
                .append(String.format("üìÖ %s%n%n", LocalDate.now()))
                .append(String.format("üí∞ –í—Å–µ–≥–æ –ø—Ä–æ–¥–∞–∂: %d%n", totalSales))
                .append(String.format("üë§ –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤: %d%n", customerMap.size()))
                .append(String.format("‚úÖ –ö–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–∞–ø–∏—Å–∏: %d%n", validCount))
                .append(String.format("‚ö†Ô∏è –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–∞–ø–∏—Å–∏: %d%n%n", invalidCount))
                .append("üöò *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞:*\n");

        sendToTelegram(message.toString());
    }

    private CustomerData parseCustomer(String raw) {
        try {
            String name = extractValue(raw, "name='([^']+)");
            int legPower = parseInt(extractValue(raw, "legPower=([\\d-]+)"));
            int handPower = parseInt(extractValue(raw, "handPower=([\\d-]+)"));
            int iq = parseInt(extractValue(raw, "iq=([\\d-]+)"));

            // –ü–∞—Ä—Å–∏–º –∞–≤—Ç–æ–º–æ–±–∏–ª–∏
            String carsStr = extractValue(raw, "cars=\\[([^]]+)]");
            int carsCount = carsStr == null ? 0 : carsStr.split(",").length;

            // –ü–∞—Ä—Å–∏–º –∫–∞—Ç–∞–º–∞—Ä–∞–Ω—ã
            boolean hasCatamaran = !raw.contains("catamaran=null");

            return CustomerData.createValid(
                    name,
                    legPower,
                    handPower,
                    iq,
                    carsCount,
                    hasCatamaran ? 1 : 0
            );
        } catch (Exception e) {
            return CustomerData.INVALID;
        }
    }

    private void sendToTelegram(String message) {
        log.warn("sending to tg");
        SendMessage sendMessage = new SendMessage(
                notificationBot.getChatId(),
                message
        );
        try {
            notificationBot.execute(sendMessage);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private String extractValue(String input, String regex) {
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(input);
        return matcher.find() ? matcher.group(1).trim() : null;
    }
}